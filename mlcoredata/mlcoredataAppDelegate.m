/**
Implementation: Read csv's into strings utilizing category for parsing.  
Write arrays generated by csv parsing into RW and RO Core Data persistent stores.

@class mlcoredataAppDelegate mlcoredataAppDelegate.h
*/

#import "mlcoredataAppDelegate.h"
#import "Utility.h"

@implementation mlcoredataAppDelegate

- (void)applicationDidFinishLaunching:(NSNotification *)aNotification
{
    
    _insertResults = [[NSMutableString alloc] init];
    [self invokeUtility];
    
}

/**
    Returns the directory the application uses to store the Core Data store file. This code uses a directory named "mlcoredata" in the user's Library directory.
 */
- (NSURL *)applicationFilesDirectory {

    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSURL *libraryURL = [fileManager URLsForDirectory:NSLibraryDirectory inDomains:NSUserDomainMask].lastObject;
    return [libraryURL URLByAppendingPathComponent:@"mlcoredata"];
}

/**
    Creates if necessary and returns the managed object model for the application.
 */
- (NSManagedObjectModel *)managedObjectModel {
    
    if (__managedObjectModel) {
        
        return __managedObjectModel;
    }
    
    //    /Users/aaxe/Library/Application Support/iPhone Simulator/4.0.2/Applications/BB194298-73FA-4B4F-8C8F-60D88600AC66/MoraLife.app/UserData.momd
    
    //    /Users/aaxe/Documents/teamaxe/code/moralife/Classes/ModelUserData.momd

    	
	NSString *pathReadOnly = [[NSBundle mainBundle] pathForResource:@"SystemData" ofType:@"momd"];
//	NSURL *momURLReadOnly = [NSURL fileURLWithPath:@"/Users/aaxe/Documents/teamaxe/code/moralife/Classes/Model/SystemData.momd/"];
	NSURL *momURLReadOnly = [NSURL fileURLWithPath:pathReadOnly];

	__managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:momURLReadOnly];      
	    
    return __managedObjectModel;
}

- (NSManagedObjectModel *)readWriteManagedObjectModel {
    
    if (__readWriteManagedObjectModel) {
        
        return __readWriteManagedObjectModel;
    }
    
    //    /Users/aaxe/Library/Application Support/iPhone Simulator/4.0.2/Applications/BB194298-73FA-4B4F-8C8F-60D88600AC66/MoraLife.app/UserData.momd
    
    //    /Users/aaxe/Documents/teamaxe/code/moralife/Classes/ModelUserData.momd
    
    
    NSString *pathReadWrite = [[NSBundle mainBundle] pathForResource:@"UserData" ofType:@"momd"];
    //	NSURL *momURLReadWrite = [NSURL fileURLWithPath:@"/Users/aaxe/Documents/teamaxe/code/moralife/Classes/Model/UserData.momd/"];
	NSURL *momURLReadWrite = [NSURL fileURLWithPath:pathReadWrite];
	__readWriteManagedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:momURLReadWrite]; 
		    
    return __readWriteManagedObjectModel;
}

/**
    Returns the persistent store coordinator for the application. This implementation creates and return a coordinator, having added the store for the application to it. (The directory for the store is created, if necessary.)
 */
- (NSPersistentStoreCoordinator *) persistentStoreCoordinator {
    if (__persistentStoreCoordinator) {
        NSLog(@"persistent store already exists");
        return __persistentStoreCoordinator;
    }

    NSManagedObjectModel *mom = self.managedObjectModel;
    if (!mom) {
        NSLog(@"%@:%@ No model to generate a store from", [self class], NSStringFromSelector(_cmd));
        return nil;
    }

    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSURL *applicationFilesDirectory = [self applicationFilesDirectory];
    NSError *error = nil;
    
    NSDictionary *properties = [applicationFilesDirectory resourceValuesForKeys:@[NSURLIsDirectoryKey] error:&error];
        
    if (!properties) {
        BOOL ok = NO;
        if (error.code == NSFileReadNoSuchFileError) {
            ok = [fileManager createDirectoryAtPath:applicationFilesDirectory.path withIntermediateDirectories:YES attributes:nil error:&error];
        }
        if (!ok) {
            [[NSApplication sharedApplication] presentError:error];
            return nil;
        }
    }
    else {
        if ([properties[NSURLIsDirectoryKey] boolValue] != YES) {
            // Customize and localize this error.
            NSString *failureDescription = [NSString stringWithFormat:@"Expected a folder to store application data, found a file (%@).", applicationFilesDirectory.path]; 
            
            NSMutableDictionary *dict = [NSMutableDictionary dictionary];
            [dict setValue:failureDescription forKey:NSLocalizedDescriptionKey];
            error = [NSError errorWithDomain:@"YOUR_ERROR_DOMAIN" code:101 userInfo:dict];
            
            [[NSApplication sharedApplication] presentError:error];
            return nil;
        }
    }
    
    NSURL *momURLReadOnly = [NSURL fileURLWithPath:@"/Users/adamaxe/Workspace/projects/teamaxe/code/moralife/Classes/Model/SystemData.sqlite"];
    
    NSFileManager *deleteFileManager = [NSFileManager defaultManager];
    [deleteFileManager removeItemAtURL:momURLReadOnly error:nil];
    
    __persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:mom];
    
    NSDictionary *options = @{NSMigratePersistentStoresAutomaticallyOption: @YES, NSInferMappingModelAutomaticallyOption: @YES};
    	
	if (![__persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:momURLReadOnly options:options error:&error]) {
        
        NSLog(@"Unresolved error %@, %@", error, error.userInfo);
        abort();
    } 
    
    return __persistentStoreCoordinator;
}

- (NSPersistentStoreCoordinator *) readWritePersistentStoreCoordinator {
    if (__readWritePersistentStoreCoordinator) {
        NSLog(@"persistent store already exists");
        return __readWritePersistentStoreCoordinator;
    }
    
    NSManagedObjectModel *mom = self.readWriteManagedObjectModel;
    if (!mom) {
        NSLog(@"%@:%@ No model to generate a store from", [self class], NSStringFromSelector(_cmd));
        return nil;
    }
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSURL *applicationFilesDirectory = [self applicationFilesDirectory];
    NSError *error = nil;
    
    NSDictionary *properties = [applicationFilesDirectory resourceValuesForKeys:@[NSURLIsDirectoryKey] error:&error];
    
    if (!properties) {
        BOOL ok = NO;
        if (error.code == NSFileReadNoSuchFileError) {
            ok = [fileManager createDirectoryAtPath:applicationFilesDirectory.path withIntermediateDirectories:YES attributes:nil error:&error];
        }
        if (!ok) {
            [[NSApplication sharedApplication] presentError:error];
            return nil;
        }
    }
    else {
        if ([properties[NSURLIsDirectoryKey] boolValue] != YES) {
            // Customize and localize this error.
            NSString *failureDescription = [NSString stringWithFormat:@"Expected a folder to store application data, found a file (%@).", applicationFilesDirectory.path]; 
            
            NSMutableDictionary *dict = [NSMutableDictionary dictionary];
            [dict setValue:failureDescription forKey:NSLocalizedDescriptionKey];
            error = [NSError errorWithDomain:@"YOUR_ERROR_DOMAIN" code:101 userInfo:dict];
            
            [[NSApplication sharedApplication] presentError:error];
            return nil;
        }
    }
    
	NSURL *momURLReadWrite = [NSURL fileURLWithPath:@"/Users/adamaxe/Workspace/projects/teamaxe/code/moralife/Classes/Model/UserData.sqlite"];    
    
    NSFileManager *deleteFileManager = [NSFileManager defaultManager];
    [deleteFileManager removeItemAtURL:momURLReadWrite error:nil];
    
    __readWritePersistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:mom];
    
    NSDictionary *options = @{NSMigratePersistentStoresAutomaticallyOption: @YES, NSInferMappingModelAutomaticallyOption: @YES};
    
    if (![__readWritePersistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:momURLReadWrite options:options error:&error]) {
        
        NSLog(@"Unresolved error %@, %@", error, error.userInfo);
        abort();
    }
    
    return __readWritePersistentStoreCoordinator;
}

/**
    Returns the managed object context for the application (which is already
    bound to the persistent store coordinator for the application.) 
 */
- (NSManagedObjectContext *) managedObjectContext {
    if (__managedObjectContext) {
        return __managedObjectContext;
    }

    NSPersistentStoreCoordinator *coordinator = self.persistentStoreCoordinator;
    if (!coordinator) {
        NSMutableDictionary *dict = [NSMutableDictionary dictionary];
        [dict setValue:@"Failed to initialize the store" forKey:NSLocalizedDescriptionKey];
        [dict setValue:@"There was an error building up the data file." forKey:NSLocalizedFailureReasonErrorKey];
        NSError *error = [NSError errorWithDomain:@"YOUR_ERROR_DOMAIN" code:9999 userInfo:dict];
        [[NSApplication sharedApplication] presentError:error];
        return nil;
    }
    __managedObjectContext = [[NSManagedObjectContext alloc] init];
    __managedObjectContext.persistentStoreCoordinator = coordinator;

    return __managedObjectContext;
}

- (NSManagedObjectContext *) readWriteManagedObjectContext {
    if (__readWriteManagedObjectContext) {
        return __readWriteManagedObjectContext;
    }
    
    NSPersistentStoreCoordinator *coordinator = self.readWritePersistentStoreCoordinator;
    if (!coordinator) {
        NSMutableDictionary *dict = [NSMutableDictionary dictionary];
        [dict setValue:@"Failed to initialize the store" forKey:NSLocalizedDescriptionKey];
        [dict setValue:@"There was an error building up the data file." forKey:NSLocalizedFailureReasonErrorKey];
        NSError *error = [NSError errorWithDomain:@"YOUR_ERROR_DOMAIN" code:9999 userInfo:dict];
        [[NSApplication sharedApplication] presentError:error];
        return nil;
    }
    __readWriteManagedObjectContext = [[NSManagedObjectContext alloc] init];
    __readWriteManagedObjectContext.persistentStoreCoordinator = coordinator;
    
    return __readWriteManagedObjectContext;
}

/**
    Returns the NSUndoManager for the application. In this case, the manager returned is that of the managed object context for the application.
 */
- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window {
    return self.managedObjectContext.undoManager;
}

/**
    Performs the save action for the application, which is to send the save: message to the application's managed object context. Any encountered errors are presented to the user.
 */
- (IBAction) saveAction:(id)sender {
    NSError *error = nil;
    
    if (![self.managedObjectContext commitEditing]) {
        NSLog(@"%@:%@ unable to commit editing before saving", [self class], NSStringFromSelector(_cmd));
    }

    if (![self.managedObjectContext save:&error]) {
        [[NSApplication sharedApplication] presentError:error];
    }

    if (![self.readWriteManagedObjectContext commitEditing]) {
        NSLog(@"%@:%@ unable to commit editing before saving", [self class], NSStringFromSelector(_cmd));
    }
    
    if (![self.readWriteManagedObjectContext save:&error]) {
        [[NSApplication sharedApplication] presentError:error];
    }
}

- (IBAction)runConversion: sender{
    
    [self invokeUtility];
}

- (void) invokeUtility {
    
    resultsView.string = @"";
    [_insertResults setString:@""];
    
    // Insert code here to initialize your application
    Utility *moralifeUtility = [[Utility alloc] init];
    
    
    [resultsView insertText:_insertResults];
    
}

- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender {

    // Save changes in the application's managed object context before the application terminates.

    if (!__managedObjectContext) {
        return NSTerminateNow;
    }

    if (!__readWriteManagedObjectContext) {
        return NSTerminateNow;
    }

    if (![self.managedObjectContext commitEditing]) {
        NSLog(@"%@:%@ unable to commit editing to terminate", [self class], NSStringFromSelector(_cmd));
        return NSTerminateCancel;
    }

    if (!self.managedObjectContext.hasChanges) {
        return NSTerminateNow;
    }
    
    if (![self.readWriteManagedObjectContext commitEditing]) {
        NSLog(@"%@:%@ unable to commit editing to terminate", [self class], NSStringFromSelector(_cmd));
        return NSTerminateCancel;
    }
    
    if (!self.readWriteManagedObjectContext.hasChanges) {
        return NSTerminateNow;
    }    

    NSError *error = nil;
    NSString *question = @"Could not save changes while quitting. Quit anyway?";
    NSString *info = @"Quitting now will lose any changes you have made since the last successful save";
    NSString *quitButton = @"Quit anyway";
    NSString *cancelButton = @"Cancel";
    if (![self.managedObjectContext save:&error]) {

        // Customize this code block to include application-specific recovery steps.
        BOOL result = [sender presentError:error];
        if (result) {
            return NSTerminateCancel;
        }

        NSAlert *alert = [[NSAlert alloc] init];
        alert.messageText = question;
        alert.informativeText = info;
        [alert addButtonWithTitle:quitButton];
        [alert addButtonWithTitle:cancelButton];

        NSInteger answer = [alert runModal];
        alert = nil;
        
        if (answer == NSAlertAlternateReturn) {
            return NSTerminateCancel;
        }
    }
    
    if (![self.readWriteManagedObjectContext save:&error]) {
        
        // Customize this code block to include application-specific recovery steps.              
        BOOL result = [sender presentError:error];
        if (result) {
            return NSTerminateCancel;
        }
        
        NSAlert *alert = [[NSAlert alloc] init];
        alert.messageText = question;
        alert.informativeText = info;
        [alert addButtonWithTitle:quitButton];
        [alert addButtonWithTitle:cancelButton];
        
        NSInteger answer = [alert runModal];
        alert = nil;
        
        if (answer == NSAlertAlternateReturn) {
            return NSTerminateCancel;
        }
    }

    return NSTerminateNow;
}


@end
